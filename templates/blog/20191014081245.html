<h2> What does Perl mean by covering Lisp? </ H2>

Perl author Larry Wall said, "Dynamic languages ​​are Lisp covered", but what exactly does this mean?

Perl and Lisp look like something completely different on the surface.

<h4> Perl grammar </ h4>

Write Perl's addition grammar.

<pre>
# Perl addition
my $ out1 = $ x + $ y
my $ out2 = $ out1 + 5;
</ pre>

<h4> Lisp grammar </ h4>

Lisp addition grammar.

<pre>
Addition of Lisp
(+ (+ x y) 5)
</ pre>

<h3> What does Perl mean by covering Lisp? </ H3>

Let's compare what Perl means to cover Lisp.

<h4> It is human convenience to put the operator in the middle </ h4>

Perl has no parentheses and the "+" sign is in the middle. On the other hand, Lisp has parentheses. And the "+" sign is at the beginning.

In Lisp, both function calls and operators come first. In other words, what is called an instruction always comes first.

In fact, putting the "+" sign in the middle means that when humans write math notation, it's customary to write it in the middle, so it's easy to see.

From the computer's point of view, function call instructions and addition instructions naturally come first. In fact, in machine language and assembler, it comes first.

The fact that the "+" comes in the middle is syntactic sugar from a human point of view, isn't it?

<h4> Lisp executes the syntax tree itself </ h4>

Lisp is also a nest of parentheses, which actually represents the syntax tree itself.

"(+ X y)" exists as the node to the left of the first "+" operation. Then, it will be executed sequentially from the node belonging to the lower left.

This just corresponds to Perl running sequentially from the bottom left node after it has been compiled into an abstract syntax tree.

That is, Perl has the same structure as Lisp when compiled into a syntax tree.

<h4> Lisp proved that the program works just with the presence of lists and instructions </ h4>

The great thing about Lisp is that it proves that a program works just by the presence of lists and instructions. Lists are dynamic data structures that can be pushed and popped.

The program runs in the presence of dynamic data structures and instructions. Oops, isn't this exactly Perl?

<pre>
#Functional instructions
sub foo {
  #Dynamic list
  my ($ num1, $ num2, $ num3) = @_;
}
</ pre>

Perl and Lisp look completely different on the surface, but Perl was a cover of Lisp for human convenience.

It is no exaggeration to say that all dynamic languages ​​benefit from Lisp in this sense.